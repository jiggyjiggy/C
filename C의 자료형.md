https://en.wikipedia.org/wiki/C_data_types

primitive types (기본 자료형)

char 
short 
int 
long
float 
double 
long 
double

!!!! 중요
어떤 자료형을 얘기 할때는 
딱 "몇 바이트야" 라고 말하는 기준자체가 애매한 자료형이 있다
해당 부분은 "표준" 자체에서 잘 얘기를 안해 놓은 것임 ; ex: char



unsigned 와 signed
unsigned 라는 단어를 자료형 이름앞에 넣어줘야 함
    - unsigned char, unsigned int 

    - '부호 있음'을 명확하게 보여주기 위해서 signed 를 붙일 수도 잇음 (하지만 생략 가능)
        - signed char, signed int

    - unsigned / signed 를 생략하면 '부호 있음(signed)' 이 기본
        - 예외: char  ; C에서 character 는 1바이트 짜리 정수임 (1바이트: 컴퓨터에서 데이터를 '읽어오는' 가장 작은 단위)


코드 예시 

char default_char = 100;
signed char signed_char = -100;
unsigned char unsigned_char = 255;

int default_int = -10000;
signed int signed_int = -10000;
unsigned int unsigned_int = 234545;



char ch_a = 'a';
char ch_b = ch_a + 1; /* b */
char ch_c = 99;       /* c */

표준에서 char는 1바이트라고 정의하고 있지 않음

표준은 8비트 이상 이라고만 정의하고있음! 
바꿔 말하면, "나는 char를 1백만 비트로 만들꺼야" 라고 해도 표준에 맞음 
(= 컴파일러 멋대로 1백만 비트도 가능하다)
    - 어떤 컴파일러를 사용하느냐에 따라 char가 8비트 일 수 도 있고, 16비트 일 수 도 있고, 9비트 일수도 있고

-> 모든 내용을 종합해보자면 = char는 최소 8비트인 정수형
 


 그렇다면 char가 몇 비트인지 찾는 방법은? 

 <limits.h> 헤더를 인클루드 한 뒤,
 CHAR_BIT를 보면 몇 비트인지 알수 있음

 참고로 C 표준은 기본 자료형의 정확한 바이트 수를 강요하지 않는다 ; 각 컴파일러마다 알아서 하라고 한다
 더 나아가 1바이트를 CHAR_BIT 만큼이라고 말함! 
    -> 1바이트는 비트 8개가 모인것; 보통 다른 언어에서는 이럼
    -> 그러나 C에서는 1바이트가 8비트가 아닐 수 있다
        - C에서는 CHAR_BIT이 8비트면 그게 1바이트이고, 16비트면 그게 1바이트 이다

char 라는 것은 내가 돌리는 기계에서 표현 할 수 있는 가장 작은 단위의 메모리!
내가 접근하고 데이터를 저장하는 단위의, 가장 작은 메모리
그게 어떤 기계에서는 1바이트 일 수도 있고, 어떤 기계에서는 2바이트 일 수도 있음
    -> 일반적으로는 8비트로 저장, 16바이트로 저장; 이게 char 라는 것임 
    -> 그러므로 C에서 바이트라고 하는 개념은, char의 크기이다; 지금 사용하고 있는 기계에 가장 작은 단위
    -> 그 단위가 16비트라면, 16비트가 1바이트이다. 그리고 그 1바이트가 char의 사이즈 인 것.

왜? 소형기기에 따라 특정 크기를 사용하는게 어려울 수도



char와 ASCII문자

정수형
char는 ASCII 문자를 표현하기에 충분; ASCII는 0~127 인 숫자
8비트에서 맨 앞 비트(최 상위 비트)는 부호



char와 signed / unsigned

정수형이니 signed 와 unsigned 가 있음
signed / unsigned를 생략하면 ; 보통 signed라고 생각하지만

C 표준은 그런걸 정하지 않았기에, 컴파일러마다 다르다

clang, 윈도우 기준으로 signed 이다




char 의 기본 부호가 지정 안된 이유?

- ASCII의 범위는 0~127 이므로 부호여부는 상관이 없음
- 단, 8비트 정수형으로 쓰려고 할때는
반드시 char 앞에 signed 나 unsigned를 넣어주는 게 좋음

signed char signed_char = -1;
unsigned char unsigned_char = 255;

- 안 그러면 포팅해도 문제없는 정수 범위는 0~127 사이 뿐이다!




char의 부호 여부를 판단하는 방법은?

- <limits.h> 헤더 파일에서 CHAR_MIN을 보면 부호 식별자가 없는 char 가 signed 인지 unsigned 인지 알 수 있다




char로 표현 가능한 숫자의 범위 (표준)

- 포팅 문제 없는 범위
unsigned char : 0~255
char          : 0~127
signed char   : -127~127

-> signed char가 뭔가 수상하다 수상해!
왜 -128이 아니라 -127인걸까?
    - 1의 보수 : (1의 보수 시스템에서는 +0, -0 존재)
        - 아주아주 옛날 기계는 1의 보수를 쓸수도 있음
        - 그러나 이제 그런 기계는 거의 없음
        - 그래도 '안전한' 포팅을 위해서는 -128이 아니라 -127
    ;포팅 문제 없는 범위는 1의 보수를 얘기하는 것임!
    2의 보수가 되는 순간 -128~127인데, 1의 보수를 지원하는 기계용으로 컴파일하면 -128이 사라짐




char로 표현 가능한 숫자의 범위 (보통)

표준은 표준이고,,,

실제 보통(데스크톱 개발 시) 안전하게 생각해도 되는것
    1. 크기: 8비트
    2. 부호(unsigned / signed)를 생략할 경우: signed 
        char signed_char = -1;
    3. 범위
        부호 없는 경우(unsigned) : 0~255
        부호 있는 경우(signed) : -128~127




quiz
1. 
Q. C 표준에 따르면 char 형의 크기는?
A. 최소 8비트

2. 
Q. signed/unsigned 가 생략된 char 형에 대해 옳은 설명
A. C 표준은 signed/unsigned 가 생략된 char 형이 signed 인지, unsigned 인지에 대해 정의하지 않으며, 이것은 컴파일러 구현에 따라 달라진다.

3.
Q. C 표준에 따르면 signed char로 표현 가능한 숫자의 범위는?
A. -127 ~ 127

4. 
Q. C 표준에 따르면 unsigned char로 표현 가능한 숫자의 범위는?
A. 0 ~ 255


------------------------------------------------------------------------------


short

short num = -30000; /* 기본: signed */
unsigned short unsigned_short = 65535;
signed short signed_short = -32767;

- 최소 16비트이고 char 의 크기 이상인 정수형 ; (초과 X, 이상 O); char가 2바이트면 short이 2바이트 일 수 있고, 3바이트일수 잇음, 단 char 가 최소 8비트 이상인거고, short은 최소 16비트 이상인 것.
    
- 포팅 문제 없는 값의 범위
    - 부호 없는 short (unsigned short) : 0 ~ 65535
    - 부호 있는 short (signed short) : -32767 ~ 32767

기본 정수형(보통 int)보다 짧음; 즉, 메모리를 적게 쓰기위해 사용
그러나 int 대신 short를 사용할 경우 성능이 느려질 수도 있다
    - 실제 CPU 계산하거나 이럴때는 int가 기본 크기인 경우가 많기 때문에, 
    - 그 int 기본 크기보다 작은걸로 계산할 경우, CPU가 여러가지 일을 해야한다
    - (작은 것을 가져다가 계산하려면, 크기가 안맞을때가 있어서)
    따라서 일반적으로 int 그냥 쓰고, 정말 메모리 줄이는 것이 필요하면 작은 것 쓰라고 하는 것

표준에 상관없이 보통 안전하게 생각해도 되는것
    1. 크기: 16비트
    2. 범위 (2의 보수 시스템)
        - 부호 없는 경우 (unsigned) : 0 ~ 65535
        - 부호 있는 경우 (signed) : -32767 ~ 32767

------------------------------------------------------------------------------

int

int num = -32767;   /* 기본: signed */
unsigned int unsigned_int = 65535;
signed int signed_int = -32767;

quiz
1.
Q. C89 표준에 따른 int는 몇 비트 일까요?
A. 최소 16비트 그리고 short 크기 이상

-> 최소 32비트가 아님!!!

표준에 따르면 최소 16비트 그리고 short 크기 이상인 정수형



int 는 "기본" 정수

- int 는 그냥 "정수(integer)" 라는 의미
- 따라서, CPU 에게 앞뒤 생략하고 "정수 처리해!"라고 하면 CPU가 딱 아는 크기여야 함
- 그게 무엇의 크기일까?
    - CPU의 산술논리장치(ALU, Arithmetic Logic Unit)가 사용하는 기본 데이터
    - 이 데이터를 워드(word)라 하고, 그 크기를 워드 크기(size) 라고 함
    - 워드 크기는 레지스터 크기랑 일치
- 즉, CPU 따라 다름
- 예전에는 16비트 CPU가 흔했음 -> 그래서 최소 16비트


int와 64비트 플랫폼

- 그 뒤에 32비트 컴퓨터가 나오면서 int의 크기는 32비트가 됨
- 그러나 이제 64비트 컴퓨터인데? -> 그래도 32비트로 머묾 (...)
    - 원칙적으로 말하면 C 표준을 어긴 것
    - 그러나 64비트로 올리면 32비트 정수를 어떻게 표현하지? (...)
    - 너무 오랫동안 32비트를 int의 크기로 사용 (다른 언어들도 마찬가지!)
    - 32비트에서 64비트로 바꾼다고 성능이 무조건 빨라지지도 않음 (이유: 캐시 메모리 등)
    - int를 64비트로 올리면 short은...? 32비트가 되어야 하나...?


int로 표현 가능한 숫자의 범위
- 포팅에 안전한 범위: short와 같음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    1. 크기: 32비트
    2. 범위 
        - 부호 없는 경우 (unsigned) : 0~ 4,294,987,295
        - 부호 있는 경우 (signed)   : -2,147,483,648 ~ 2,147,483,657 


int의 리터럴

int signed_int = -1024;
unsigned int unsigned_int1 = 394;
unsigned int unsigned_int2 = 2147483648;    /* 경고 */
unsigned int unsigned_int3 = 2147483648u;    /* 경고 없음, 대문자 U도 됨 */

- 리터럴(literal)
    - 'u' 혹은 'U' : 부호 없는 (unsigned) 수를 표현하는 접미사
        - 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우, 'u' 혹은 'U' 를 붙여야 함
        - 안붙이면 경고(warning) 발생

------------------------------------------------------------------------------

long

long num = -2147483648; /* 기본: signed */
unsigned long unsigned_long = 2147483647;
signed long signed_long = -2147483648;

- int가 16비트일 때 그것보다 2배 큰 자료형이 필요했음
- 따라서, long은 최소 32비트 이고 int 이상의 크기 (...)
    - 다른 언어에서는 long이 보통 64비트

- 그럼 최소  64비트인 정수형은?
    - C89에는 없음

- 포팅 안전한 범위: -2147483647 ~ 2147483647
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    - int와 같음


long의 리터럴

long signed_long = -200000000l; /* 대문자 L도 됨 */
unsigned long unsigned_long1 = 2147483647;
unsigned long unsigned_long2 = 2147483648;   /* 경고 */
unsigned long unsigned_long3 = 2147483648ul; /* 경고 없음 */

- 리터럴
    - 'l' 혹은 'L' : longdmf dmlalgksms wjqaltk
    - 'u' 혹은 'U' : 부호 없는 (unsigned) 수를 표현하는 접미사
    - 두 접미사를 같이 쓸 수 있음: unsigned long이라는 의미가 됨

    2147483645UL
    2147483645LU
    2147483645lu
    2147483645ul

quiz
1. 
Q. C 표준에 따른 long형의 크기는?
A. 최소 32비트이며 int이상

------------------------------------------------------------------------------

간단 요약

char : 최소 8비트, 보통 8비트
short : 최소 16비트, 보통 16비트 
int : 최소 16비트, 보통 32비트
long : 최소 32비트, 보통 32비트

------------------------------------------------------------------------------


float

float num = 3.14f;                      /* 컴파일 */
unsigned float unsigned_float = 3.14f;  /* 컴파일 오류 */
signed float signed_float = -3.14f;     /* 컴파일 오류 */

- '소프트웨어 공학용 수학' 과목에서 배우길, 부동소수점 자료형은 IEEE 754로 대동단결 되었다고 했음
    - float 는 IEEE 754 Single (32 비트)
    - double 은 IEEE 754 Double (64 비트)
- 하지만, C는 CPU가 IEEE 754를 지원하는 실수 계산 장치를 장착하기 전부터 쓰임 (...)

- 표준에 따르면 C의 float은
    - IEEE 754 일수도, 아닐 수도 있음 (...)
    - 역시 컴파일러 구현에 따라 다름 (최소한 C89에서는)
    - 크기는 char 이상이기만 하면 됌
- unsigned 형 없음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    - 크기: 32비트
    - 범위: IEEE 754 Single과 동일
- 관련 헤더파일: float.h


float의 리터럴

float pi1 = 3.14f;  /* F도 됨 */
float pi2 = 3.14uf; /* 컴파일 오류, float은 접미사 u를 안 씀 */

- 리터럴
    - 'f' 혹은 'F': float을 의미하는 접미사

------------------------------------------------------------------------------

double

double num = 3.14;                      /* 컴파일 */
unsigned double unsigned_double = 3.14; /* 컴파일 오류 */
signed double signed_double = -3.14;    /* 컴파일 오류 */

- 표준에 따르면 CPU가 계산에 사용하는 "기본" 데이터 크기
    - 크기는 float이상이면 됨
    - float은 그저 double보다 빠르게 연산하기 위해 만든 작은 부동소수점 (...)
- 역시 컴파일러 구현따라 다름
    - 즉, IEEE 754 Double이란 보장이 없음..
- unsigned 형 없음


- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    - 크기: 64비트
    - 범위: IEEE 754 Double과 동일 (단, 소형기기로 갈때는 조심)
- 관련 헤더 파일: float.h


------------------------------------------------------------------------------



long double

long double num = 3.14;                             /* 컴파일 */
unsigned long double unsigned_long_double = 3.14;   /* 컴파일 오류 */
signed long double signed_long_double = -3.14;      /* 컴파일 오류 */

- double 보다 정밀도가 높음
- double 이상의 크기면 됨
- 다른 부동소수점들과 마찬가지로 unsigned 형 없음
- 관련 헤더 파일: float.h



------------------------------------------------------------------------------

C에서는 float이 double보다 작은 거, 이하인 거, 
double이 CPU 에서 이해하는 기본데이터 크기
그것보다 큰 거 하려면 long double. 즉, 지금 다른 언어에서 double로 쓰고 있는게 C에서는 원래 long double이었다고 생각해도 큰 무리는 아님
그래서 double 이상 크기면 되고, 내부 구현은 어떻게 되는지 모르고, 그게 전부이다

이거 자체도 어떤 언어를 가면 ... 이거는 확실히 차이가 있더라구요,
어떤 컴파일러의 어떤 플랫폼에서 하느냐에따라 long double이 
IEEE 754 Double보다 커지는 경우가 있어요

근데 clang 윈도우 버전이라던가, 비주얼 스튜디오 C버전을 보면 
double과 long double이 똑같아요 

이게 되게 애매해 지는 부분인데, 그래서 일단 보통 플랫폼에 따라 약간 달라지죠, 제가 듣기로는 gcc 쪽은 long double이 실제 크다고 들었어요, double보다도. double이 64비트니까. gcc 윈도우, gcc 리눅스 버전에서는.

그것보다 크다고 들었어요, 그래서 이거는 지금 아직도 중구난방, 
그만큼 다른 언어에서 잘 없기 때문에 잘 쓰지 않는 부분일 수도 있어요

------------------------------------------------------------------------------

C89의 기본 자료형
캡쳐 기반으로 공부

------------------------------------------------------------------------------

우리가 여기서 얻을 수 있는 교훈

- 데스크톱에서는 다른 언어와 비슷하게 사용가능
    - 예외: long(32비트) (64비트가 아님)
- 소형기기를 다룰 때는?
    - 매뉴얼에서 자료형 크기 확인 후 사용할 것 (어떤 타입이 몇 비트인지 써있음)
- 여기저기 사용할 코드라면?
    - 포팅이 보장되는 범위의 값으로만 사용할 것 
    - float / double 은 플랫폼 사이에 값이 정확히 일치하지 않을 수 있음 (float / double 은 IEEE 754를 지원한다는 보장 자체가 없으니까! 본인 마음대로 니 하드웨어에서 float 하고 double 표현할 수 있는거 하라는 얘기) (그래서 애매하기 때문에 IEEE 754에 기초해서 어떤 비트 패턴이 나올거라고 예상을 하고, 그 비트 패턴을 저장했다가 나중에 어떻게 쓰는 이런 방식을 하신다면 제대로 안돌겠죠?) (그래서 비트 패턴에 의존하시면 안돼요)
        - 코딩할 때 충분히 대비할 것


------------------------------------------------------------------------------

quiz

1. 
Q. 일반적인 데스크탑 컴퓨터에서 float형, double형, long double형의 크기는? (표준에 따른 크기가 아님)
A. 32비트, 64비트, double 이상의 크기

------------------------------------------------------------------------------

