https://en.wikipedia.org/wiki/C_data_types

primitive types (기본 자료형)

char 
short 
int 
long
float 
double 
long 
double

!!!! 중요
어떤 자료형을 얘기 할때는 
딱 "몇 바이트야" 라고 말하는 기준자체가 애매한 자료형이 있다
해당 부분은 "표준" 자체에서 잘 얘기를 안해 놓은 것임 ; ex: char



unsigned 와 signed
unsigned 라는 단어를 자료형 이름앞에 넣어줘야 함
    - unsigned char, unsigned int 

    - '부호 있음'을 명확하게 보여주기 위해서 signed 를 붙일 수도 잇음 (하지만 생략 가능)
        - signed char, signed int

    - unsigned / signed 를 생략하면 '부호 있음(signed)' 이 기본
        - 예외: char  ; C에서 character 는 1바이트 짜리 정수임 (1바이트: 컴퓨터에서 데이터를 '읽어오는' 가장 작은 단위)


코드 예시 

char default_char = 100;
signed char signed_char = -100;
unsigned char unsigned_char = 255;

int default_int = -10000;
signed int signed_int = -10000;
unsigned int unsigned_int = 234545;



char ch_a = 'a';
char ch_b = ch_a + 1; /* b */
char ch_c = 99;       /* c */

표준에서 char는 1바이트라고 정의하고 있지 않음

표준은 8비트 이상 이라고만 정의하고있음! 
바꿔 말하면, "나는 char를 1백만 비트로 만들꺼야" 라고 해도 표준에 맞음 
(= 컴파일러 멋대로 1백만 비트도 가능하다)
    - 어떤 컴파일러를 사용하느냐에 따라 char가 8비트 일 수 도 있고, 16비트 일 수 도 있고, 9비트 일수도 있고

-> 모든 내용을 종합해보자면 = char는 최소 8비트인 정수형
 


 그렇다면 char가 몇 비트인지 찾는 방법은? 

 <limits.h> 헤더를 인클루드 한 뒤,
 CHAR_BIT를 보면 몇 비트인지 알수 있음

 참고로 C 표준은 기본 자료형의 정확한 바이트 수를 강요하지 않는다 ; 각 컴파일러마다 알아서 하라고 한다
 더 나아가 1바이트를 CHAR_BIT 만큼이라고 말함! 
    -> 1바이트는 비트 8개가 모인것; 보통 다른 언어에서는 이럼
    -> 그러나 C에서는 1바이트가 8비트가 아닐 수 있다
        - C에서는 CHAR_BIT이 8비트면 그게 1바이트이고, 16비트면 그게 1바이트 이다

char 라는 것은 내가 돌리는 기계에서 표현 할 수 있는 가장 작은 단위의 메모리!
내가 접근하고 데이터를 저장하는 단위의, 가장 작은 메모리
그게 어떤 기계에서는 1바이트 일 수도 있고, 어떤 기계에서는 2바이트 일 수도 있음
    -> 일반적으로는 8비트로 저장, 16바이트로 저장; 이게 char 라는 것임 
    -> 그러므로 C에서 바이트라고 하는 개념은, char의 크기이다; 지금 사용하고 있는 기계에 가장 작은 단위
    -> 그 단위가 16비트라면, 16비트가 1바이트이다. 그리고 그 1바이트가 char의 사이즈 인 것.

왜? 소형기기에 따라 특정 크기를 사용하는게 어려울 수도



char와 ASCII문자

정수형
char는 ASCII 문자를 표현하기에 충분; ASCII는 0~127 인 숫자
8비트에서 맨 앞 비트(최 상위 비트)는 부호



char와 signed / unsigned

정수형이니 signed 와 unsigned 가 있음
signed / unsigned를 생략하면 ; 보통 signed라고 생각하지만

C 표준은 그런걸 정하지 않았기에, 컴파일러마다 다르다

clang, 윈도우 기준으로 signed 이다




char 의 기본 부호가 지정 안된 이유?

- ASCII의 범위는 0~127 이므로 부호여부는 상관이 없음
- 단, 8비트 정수형으로 쓰려고 할때는
반드시 char 앞에 signed 나 unsigned를 넣어주는 게 좋음

signed char signed_char = -1;
unsigned char unsigned_char = 255;

- 안 그러면 포팅해도 문제없는 정수 범위는 0~127 사이 뿐이다!




char의 부호 여부를 판단하는 방법은?

- <limits.h> 헤더 파일에서 CHAR_MIN을 보면 부호 식별자가 없는 char 가 signed 인지 unsigned 인지 알 수 있다




char로 표현 가능한 숫자의 범위 (표준)

- 포팅 문제 없는 범위
unsigned char : 0~255
char          : 0~127
signed char   : -127~127

-> signed char가 뭔가 수상하다 수상해!
왜 -128이 아니라 -127인걸까?
    - 1의 보수 : (1의 보수 시스템에서는 +0, -0 존재)
        - 아주아주 옛날 기계는 1의 보수를 쓸수도 있음
        - 그러나 이제 그런 기계는 거의 없음
        - 그래도 '안전한' 포팅을 위해서는 -128이 아니라 -127
    ;포팅 문제 없는 범위는 1의 보수를 얘기하는 것임!
    2의 보수가 되는 순간 -128~127인데, 1의 보수를 지원하는 기계용으로 컴파일하면 -128이 사라짐




char로 표현 가능한 숫자의 범위 (보통)

표준은 표준이고,,,

실제 보통(데스크톱 개발 시) 안전하게 생각해도 되는것
    1. 크기: 8비트
    2. 부호(unsigned / signed)를 생략할 경우: signed 
        char signed_char = -1;
    3. 범위
        부호 없는 경우(unsigned) : 0~255
        부호 있는 경우(signed) : -128~127




quiz
1. 
Q. C 표준에 따르면 char 형의 크기는?
A. 최소 8비트

2. 
Q. signed/unsigned 가 생략된 char 형에 대해 옳은 설명
A. C 표준은 signed/unsigned 가 생략된 char 형이 signed 인지, unsigned 인지에 대해 정의하지 않으며, 이것은 컴파일러 구현에 따라 달라진다.

3.
Q. C 표준에 따르면 signed char로 표현 가능한 숫자의 범위는?
A. -127 ~ 127

4. 
Q. C 표준에 따르면 unsigned char로 표현 가능한 숫자의 범위는?
A. 0 ~ 255


------------------------------------------------------------------------------


short

short num = -30000; /* 기본: signed */
unsigned short unsigned_short = 65535;
signed short signed_short = -32767;

- 최소 16비트이고 char 의 크기 이상인 정수형 ; (초과 X, 이상 O); char가 2바이트면 short이 2바이트 일 수 있고, 3바이트일수 잇음, 단 char 가 최소 8비트 이상인거고, short은 최소 16비트 이상인 것.
    
- 포팅 문제 없는 값의 범위
    - 부호 없는 short (unsigned short) : 0 ~ 65535
    - 부호 있는 short (signed short) : -32767 ~ 32767

기본 정수형(보통 int)보다 짧음; 즉, 메모리를 적게 쓰기위해 사용
그러나 int 대신 short를 사용할 경우 성능이 느려질 수도 있다
    - 실제 CPU 계산하거나 이럴때는 int가 기본 크기인 경우가 많기 때문에, 
    - 그 int 기본 크기보다 작은걸로 계산할 경우, CPU가 여러가지 일을 해야한다
    - (작은 것을 가져다가 계산하려면, 크기가 안맞을때가 있어서)
    따라서 일반적으로 int 그냥 쓰고, 정말 메모리 줄이는 것이 필요하면 작은 것 쓰라고 하는 것

표준에 상관없이 보통 안전하게 생각해도 되는것
    1. 크기: 16비트
    2. 범위 (2의 보수 시스템)
        - 부호 없는 경우 (unsigned) : 0 ~ 65535
        - 부호 있는 경우 (signed) : -32767 ~ 32767

------------------------------------------------------------------------------

int

int num = -32767;   /* 기본: signed */
unsigned int unsigned_int = 65535;
signed int signed_int = -32767;

quiz
1.
Q. C89 표준에 따른 int는 몇 비트 일까요?
A. 최소 16비트 그리고 short 크기 이상

-> 최소 32비트가 아님!!!

표준에 따르면 최소 16비트 그리고 short 크기 이상인 정수형



int 는 "기본" 정수

- int 는 그냥 "정수(integer)" 라는 의미
- 따라서, CPU 에게 앞뒤 생략하고 "정수 처리해!"라고 하면 CPU가 딱 아는 크기여야 함
- 그게 무엇의 크기일까?
    - CPU의 산술논리장치(ALU, Arithmetic Logic Unit)가 사용하는 기본 데이터
    - 이 데이터를 워드(word)라 하고, 그 크기를 워드 크기(size) 라고 함
    - 워드 크기는 레지스터 크기랑 일치
- 즉, CPU 따라 다름
- 예전에는 16비트 CPU가 흔했음 -> 그래서 최소 16비트


int와 64비트 플랫폼

- 그 뒤에 32비트 컴퓨터가 나오면서 int의 크기는 32비트가 됨
- 그러나 이제 64비트 컴퓨터인데? -> 그래도 32비트로 머묾 (...)
    - 원칙적으로 말하면 C 표준을 어긴 것
    - 그러나 64비트로 올리면 32비트 정수를 어떻게 표현하지? (...)
    - 너무 오랫동안 32비트를 int의 크기로 사용 (다른 언어들도 마찬가지!)
    - 32비트에서 64비트로 바꾼다고 성능이 무조건 빨라지지도 않음 (이유: 캐시 메모리 등)
    - int를 64비트로 올리면 short은...? 32비트가 되어야 하나...?


int로 표현 가능한 숫자의 범위
- 포팅에 안전한 범위: short와 같음
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    1. 크기: 32비트
    2. 범위 
        - 부호 없는 경우 (unsigned) : 0~ 4,294,987,295
        - 부호 있는 경우 (signed)   : -2,147,483,648 ~ 2,147,483,657 


int의 리터럴

int signed_int = -1024;
unsigned int unsigned_int1 = 394;
unsigned int unsigned_int2 = 2147483648;    /* 경고 */
unsigned int unsigned_int3 = 2147483648u;    /* 경고 없음, 대문자 U도 됨 */

- 리터럴(literal)
    - 'u' 혹은 'U' : 부호 없는 (unsigned) 수를 표현하는 접미사
        - 부호 있는 수의 최댓값보다 큰 값을 unsigned int에 대입할 경우, 'u' 혹은 'U' 를 붙여야 함
        - 안붙이면 경고(warning) 발생

------------------------------------------------------------------------------

long

long num = -2147483648; /* 기본: signed */
unsigned long unsigned_long = 2147483647;
signed long signed_long = -2147483648;

- int가 16비트일 때 그것보다 2배 큰 자료형이 필요했음
- 따라서, long은 최소 32비트 이고 int 이상의 크기 (...)
    - 다른 언어에서는 long이 보통 64비트

- 그럼 최소  64비트인 정수형은?
    - C89에는 없음

- 포팅 안전한 범위: -2147483647 ~ 2147483647
- 표준에 상관없이 보통 안전하게 생각해도 되는 것
    - int와 같음


long의 리터럴

long signed_long = -200000000l; /* 대문자 L도 됨 */
unsigned long unsigned_long1 = 2147483647;
unsigned long unsigned_long2 = 2147483648;   /* 경고 */
unsigned long unsigned_long3 = 2147483648ul; /* 경고 없음 */

- 리터럴
    - 'l' 혹은 'L' : longdmf dmlalgksms wjqaltk
    - 'u' 혹은 'U' : 부호 없는 (unsigned) 수를 표현하는 접미사
    - 두 접미사를 같이 쓸 수 있음: unsigned long이라는 의미가 됨

    2147483645UL
    2147483645LU
    2147483645lu
    2147483645ul

quiz
1. 
Q. C 표준에 따른 long형의 크기는?
A. 최소 32비트이며 int이상

------------------------------------------------------------------------------

간단 요약

char : 최소 8비트, 보통 8비트
short : 최소 16비트, 보통 16비트 
int : 최소 16비트, 보통 32비트
long : 최소 32비트, 보통 32비트

------------------------------------------------------------------------------
